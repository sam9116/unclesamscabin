<!DOCTYPE html>
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ms="urn:schemas-microsoft-com:xslt" xmlns:bat="http://schemas.microsoft.com/battery/2012" xmlns:js="http://microsoft.com/kernel">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="ReportUtcOffset" content="-7:00" />
    <title>LinkGen Privacy Policy</title>
    <style type="text/css">
        body {
            font-family: Segoe UI;
            letter-spacing: 0.02em;
            background-color: #181818;
            color: #F0F0F0;
            margin-left: 5.5em;
        }

        h1 {
            color: #11D8E8;
            font-size: 42pt;
            font-weight:normal;
        }

        h2 {
            font-size: 15pt;
            color: #11EEF4;
            margin-top: 4em;
            margin-bottom: 0em;
            letter-spacing: 0.08em;
        }

        td {
            padding-left: 0.3em;
            padding-right: 0.3em;
        }

        .nobatts {
            font-family: Segoe UI Semibold;
            background: #272727;
            color: #ACAC60;
            font-size: 13pt;
            padding-left: 0.4em;
            padding-right: 0.4em;
            padding-top: 0.3em;
            padding-bottom: 0.3em;
        }

        .explanation {
            color: #777777;
            font-size: 12pt;
            margin-bottom: 1em;
        }

        .explanation2 {
            color: #777777;
            font-size: 12pt;
            margin-bottom: 0.1em;
        }

        table {
            border-width: 0;
            table-layout: fixed;
            font-family: Segoe UI Light;
            letter-spacing: 0.02em;
            background-color: #181818;
            color: #f0f0f0;
        }

        .even {
            background: #272727;
        }

        .odd {
            background: #1E1E1E;
        }

        .even.suspend {
            background: #1A1A28;
        }

        .odd.suspend {
            background: #1A1A2C;
        }

        thead {
            font-family: Segoe UI Semibold;
            font-size: 85%;
            color: #BCBCBC;
        }

        text {
            font-size: 12pt;
            font-family: Segoe UI Light;
            fill: #11EEF4;
        }

        .centered {
            text-align: center;
        }

        .label {
            font-family: Segoe UI Semibold;
            font-size: 85%;
            color: #BCBCBC;
        }

        .dc.even {
            background: #40182C;
        }

        .dc.odd {
            background: #30141F;
        }

        td.colBreak {
            padding: 0;
            width: 0.15em;
        }

        td.state {
            text-align: center;
        }

        td.hms {
            font-family: Segoe UI Symbol;
            text-align: right;
            padding-right: 3.4em;
        }

        td.dateTime {
            font-family: Segoe UI Symbol;
        }

        td.nullValue {
            text-align: center;
        }

        td.percent {
            font-family: Segoe UI Symbol;
            text-align: right;
            padding-right: 2.5em;
        }

        col:first-child {
            width: 13em;
        }

        col.col2 {
            width: 10.4em;
        }

        col.percent {
            width: 7.5em;
        }

        td.mw {
            text-align: right;
            padding-right: 2.5em;
        }

        td.acdc {
            text-align: center;
        }

        span.date {
            display: inline-block;
            width: 5.5em;
        }

        span.time {
            text-align: right;
            width: 4.2em;
            display: inline-block;
        }

        text {
            font-family: Segoe UI Symbol;
        }

        .noncontigbreak {
            height: 0.3em;
            background-color: #1A1A28;
        }
    </style>
    <script type="text/javascript">

        // Formats a number using the current locale (to handle the 1000's separator).

        // The result is rounded so no decimal point is shown.

        function numberToLocaleString(value) {

            var localeString = Math.round(parseFloat(value + '')).toLocaleString();

            return localeString.substring(0, localeString.indexOf('.'));

        }



        function padLeft(number, length) {

            var str = '' + number;

            while (str.length < length) {

                str = '0' + str;

            }



            return str;

        }



        // Returns the number of milliseconds between 2 date-times represented as strings.

        function msBetween(startTime, endTime) {

            return startTime > endTime

                ? msBetween(endTime, startTime)

                : parseDateTime(endTime) - parseDateTime(startTime);

        }



        var dateFormat = /(\d{4})-(\d{2})-(\d{2})[T](\d{2}):(\d{2}):(\d{2})/



        // Parses a date-time string and returns a Date (i.e. number of milliseconds)

        function parseDateTime(value) {

            if (!value) {

                return 0;

            }



            var match = dateFormat.exec(value)

            if (!match) {

                return 0;

            }



            return Date.parse(match[1] + '/' + match[2] + '/' +

                match[3] + ' ' + match[4] + ':' +

                match[5] + ':' + match[6])

        }



        // Parses just the date portion of a date-time string and returns a Date

        // (i.e. number of milliseconds)

        function parseDate(value) {

            if (!value) {

                return 0;

            }



            var match = dateFormat.exec(value)

            if (!match) {

                return 0;

            }



            return Date.parse(match[1] + '/' + match[2] + '/' + match[3])

        }



        var durationFormat = /P((\d+)D)?T((\d+)H)?((\d+)M)?(\d+)S/



        // Convert a string of the form P10DT1H15M40S to a count of milliseconds

        function parseDurationToMs(value) {

            var match = durationFormat.exec(value)

            if (!match) {

                return 0

            }



            var days = parseInt(match[2] || '0');

            var hrs = parseInt(match[4] || '0');

            var mins = parseInt(match[6] || '0');

            var secs = parseInt(match[7] || '0');

            return ((((((days * 24) + hrs) * 60) + mins) * 60) + secs) * 1000;

        }



        // Converts milliseconds to days

        function msToDays(ms) {

            return (ms / 1000 / 60 / 60 / 24);

        }



        function daysToMs(days) {

            return (days * 24 * 60 * 60 * 1000);

        }



        // Formats a number of milliseconds as h:mm:ss

        function formatDurationMs(value) {

            var ms = parseInt(value);

            var secs = ms / 1000;

            var mins = secs / 60;

            var hrs = Math.floor(mins / 60);

            mins = Math.floor(mins % 60);

            secs = Math.floor(secs % 60);

            return hrs + ':' + padLeft(mins, 2) + ':' + padLeft(secs, 2);

        }



        // Converts a millisecond timestamp to a day and month string

        // Note: dayOffset is forward from date.

        function dateToDayAndMonth(ms, dayOffset) {

            var adjustedDate = new Date(ms + (dayOffset * 24 * 60 * 60 * 1000));

            return padLeft(adjustedDate.getMonth() + 1, 2) + "-" +

                padLeft(adjustedDate.getDate(), 2);

        }



        // Takes a millisecond timestamp and returns a new millisecond timestamp

        // rounded down to the current day.

        function dateFloor(ms) {

            var dt = new Date(ms);

            return Date.parse(dt.getFullYear() + '/' + (dt.getMonth() + 1) + '/' + dt.getDate());

        }



        Timegraph = {

            axisTop: 9.5,

            axisRight: 24.5,

            axisBottom: 25.5,

            axisLeft: 25.5,

            ticks: 10,



            // Maximum number of 24 hour ticks for showing 12 and 6 hour ticks



            ticks12Hour: 8,

            ticks6Hour: 4,



            // Shading



            lineColor: "#B82830",

            shadingColor: "#4d1d35",



            precompute: function (graph) {

                var canvas = graph.canvas;

                var data = graph.data;

                var min = 0;

                var max = 0;



                graph.height = canvas.height - Timegraph.axisTop - Timegraph.axisBottom;

                graph.width = canvas.width - Timegraph.axisLeft - Timegraph.axisRight;

                for (var i = 0; i < data.length; i++) {

                    data[i].t0 = parseDateTime(data[i].x0);

                    data[i].t1 = parseDateTime(data[i].x1);



                    if (i == 0) {

                        min = data[i].t0;

                        max = data[i].t1;

                    }



                    if (data[i].t0 < min) {

                        min = data[i].t0;

                    }



                    if (data[i].t1 > max) {

                        max = data[i].t1;

                    }



                    data[i].yy0 =

                        Timegraph.axisTop + graph.height - data[i].y0 * graph.height;



                    data[i].yy1 =

                        Timegraph.axisTop + graph.height - data[i].y1 * graph.height;

                }



                if (graph.startTime != null) {

                    graph.startMs = parseDateTime(graph.startTime);



                } else {

                    graph.startMs = min;

                }



                graph.endMs = max;

                graph.durationMs = max - min;

            },



            drawFrame: function (graph) {

                var canvas = graph.canvas;

                var context = graph.context;



                graph.width =

                    canvas.width - Timegraph.axisRight - Timegraph.axisLeft;



                graph.height =

                    canvas.height - Timegraph.axisTop - Timegraph.axisBottom;



                context.beginPath();

                context.moveTo(Timegraph.axisLeft, Timegraph.axisTop);

                context.lineTo(Timegraph.axisLeft + graph.width,

                    Timegraph.axisTop);



                context.lineTo(Timegraph.axisLeft + graph.width,

                    Timegraph.axisTop + graph.height);



                context.lineTo(Timegraph.axisLeft,

                    Timegraph.axisTop + graph.height);



                context.lineTo(Timegraph.axisLeft, Timegraph.axisTop);

                context.strokeStyle = "#c0c0c0";

                context.stroke();

            },



            drawRange: function (graph) {

                var canvas = graph.canvas;

                var context = graph.context;



                context.font = "12pt Segoe UI";

                context.fillStyle = "#00b0f0";

                context.fillText("%", 0, Timegraph.axisTop + 5, Timegraph.axisLeft);



                var tickSpacing = graph.height / 10;

                var offset = Timegraph.axisTop + tickSpacing;

                var tickValue = 90;

                for (var i = 0; i < 9; i++) {

                    context.beginPath();

                    context.moveTo(Timegraph.axisLeft, offset);

                    context.lineTo(Timegraph.axisLeft + graph.width,

                        offset);



                    context.stroke();

                    context.fillText(tickValue.toString(),

                        0,

                        offset + 5,

                        Timegraph.axisLeft);



                    offset += tickSpacing;

                    tickValue -= 10;

                }

            },



            drawDomain: function (graph, start, end) {

                var canvas = graph.canvas;

                var context = graph.context;

                var data = graph.data;

                var duration = end - start;

                if ((end < start)) {

                    return;

                }



                var startDay = dateFloor(start);

                var t0 = startDay;

                var t1 = dateFloor(end);

                var dayOffset = 0;

                if (start > t0) {

                    t0 = t0 + daysToMs(1);

                    dayOffset++;

                }



                if (t0 >= t1) {

                    return;

                }



                var increment =

                    Math.max(Math.floor((t1 - t0) / daysToMs(Timegraph.ticks)), 1);



                var incrementMs = daysToMs(increment);

                var spacing = (incrementMs / duration) * graph.width;

                var offset = (t0 - start) / duration;

                var ticksCount = Math.floor((t1 - t0) / incrementMs);

                for (offset = offset * graph.width + Timegraph.axisLeft;

                    offset < (graph.width + Timegraph.axisLeft);

                    offset += spacing) {



                    context.beginPath();

                    context.moveTo(offset, Timegraph.axisTop);

                    context.lineTo(offset, Timegraph.axisTop + graph.height);

                    context.stroke();

                    context.fillText(dateToDayAndMonth(startDay, dayOffset),

                        offset,

                        Timegraph.axisTop + graph.height + 15,

                        spacing);



                    dayOffset += increment;

                }

            },



            plot: function (graph, start, end) {

                var canvas = graph.canvas;

                var context = graph.context

                var data = graph.data;



                if ((end < start)) {

                    return;

                }



                var duration = end - start;

                Timegraph.drawDomain(graph, start, end);

                context.fillStyle = Timegraph.shadingColor;

                for (var i = 0; i < data.length - 1; i++) {

                    if ((data[i].t0 < start) || (data[i].t0 > end) ||

                        (data[i].t1 > end)) {



                        continue;

                    }



                    var x1 = (data[i].t0 - start) / duration;

                    x1 = x1 * graph.width + Timegraph.axisLeft;



                    var x2 = (data[i].t1 - start) / duration;

                    x2 = x2 * graph.width + Timegraph.axisLeft;



                    context.globalAlpha = 0.3;

                    context.fillRect(x1, Timegraph.axisTop, (x2 - x1), graph.height);

                    context.globalAlpha = 1;

                    context.beginPath();

                    context.strokeStyle = Timegraph.lineColor;

                    context.lineWidth = 1.5;

                    context.moveTo(x1, data[i].yy0);

                    context.lineTo(x2, data[i].yy1);

                    context.stroke();

                }

            },



            draw: function (graph) {

                var canvas = document.getElementById(graph.element);

                if (canvas == null) {

                    return;

                }



                var context = canvas.getContext('2d');

                if (context == null) {

                    return;

                }



                graph.width = 0;

                graph.height = 0;

                graph.context = context;

                graph.canvas = canvas;



                Timegraph.precompute(graph);

                Timegraph.drawFrame(graph);

                Timegraph.drawRange(graph);

                Timegraph.plot(graph, graph.startMs, graph.endMs);

            }

        };



        drainGraphData = [



        ];



        function main() {

            Timegraph.draw({

                element: "drain-graph",

                data: drainGraphData,

                startTime: "2017-12-09T00:20:46",

                endTime: "2017-12-12T00:20:46",

            });

        }



        if (window.addEventListener != null) {

            window.addEventListener("load", main, false);



        } else if (window.attachEvent != null) {

            window.attachEvent("onload", main);

        }

    </script>
</head>

<body>
    
    <h1>
        LinkGen Privacy Policy
    </h1>
    <div class="explanation">

        <p>    We DO NOT collect any user information whatsoever. </p>

        <p>    The use of Camera/Microphone permisson is solely to allow proper functioning of the application.</p>
        <p>    Microsoft has tied the two hardware permission together even though only camera is actually being utilized, the explanation is provided here.</p>
        <a href="https://stackoverflow.com/questions/34952684/uwp-mediacapture-denied-access-to-camera"> https://stackoverflow.com/questions/34952684/uwp-mediacapture-denied-access-to-camera </a>

        <p>    If there are any doubts, the code for this application is publicly available at </p>
        <p>    <a href="https://github.com/sam9116/linkgen"> https://github.com/sam9116/linkgen </a></p>



    </div>
    <h2><a href="http://unclesamscabin.ca" style="color:white; text-decoration: none;"> ← Back To Main Site</a> </h2>
</body>
</html>